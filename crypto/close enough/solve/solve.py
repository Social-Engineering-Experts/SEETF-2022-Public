from Crypto.Util.number import inverse, long_to_bytes
from Crypto.PublicKey import RSA
import math


def get_consecutive_primes(num):
    temp = math.isqrt(num) + 1
    temp2 = math.isqrt(temp ** 2 - n)
    p, q = temp - temp2, temp + temp2
    assert p * q == num
    return p, q


public_key = RSA.importKey(open("key", "r").read())

n = public_key.n
e = public_key.e
c = 4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017
p, q = get_consecutive_primes(n)
phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m).decode())
